/*
    <one line to give the library's name and an idea of what it does.>
    Copyright (C) 2012 Markus Bader

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA

*/

#include <v4l_cam/v4l_cam_node.h>
#include <stdio.h>
#include <string>
extern "C" {
#include "luvcview/v4l2uvc.h"
#include <libv4l2.h>
#include <linux/videodev2.h>
}
#include <boost/algorithm/string.hpp>


void LuvcNode::updateDynamicReconfigureFile() const
{
    v4l2_queryctrl queryctrl;
    v4l2_control   control_s;
    memset(&queryctrl, 0, sizeof(queryctrl));
    memset(&control_s, 0, sizeof(control_s));
    FILE *configfile;
    configfile = fopen("cfg/CameraParameters.cfg", "w");
    fprintf(configfile, "#! /usr/bin/env python\n");
    fprintf(configfile, "#Autogenerated V4L Dynamic Control\n\n");
    fprintf(configfile, "PACKAGE='luvc'\n");
    fprintf(configfile, "import roslib; roslib.load_manifest(PACKAGE)\n\n");
    fprintf(configfile, "from dynamic_reconfigure.parameter_generator import *\n");
    fprintf(configfile, "gen = ParameterGenerator()\n\n");
	
	
    fprintf(configfile, "gen.add(\"show_camera_image\", bool_t, 0, \"Show camera image\", True)\n");
    fprintf(configfile, "gen.add(\"update_dynamic_reconfigure\", bool_t, 0, \"Updates the dynamic reconfigure file\", False)\n");

    for(std::vector<ControlEntryPtr>::const_iterator it = controlEntries_.begin(); it != controlEntries_.end(); it++) {
        queryctrl.id = (*it)->queryctrl->id;

        if(0 == ioctl(pVideoIn_->fd, VIDIOC_QUERYCTRL, &queryctrl)) {
            if(queryctrl.flags & V4L2_CTRL_FLAG_DISABLED) {
                continue;
            } else {
                if(queryctrl.type == V4L2_CTRL_TYPE_INTEGER) {
                    fprintf(configfile, "gen.add(\"%s\", int_t, 0, \"%s\", %i, %i, %i)\n",
                            (*it)->varName.c_str(), queryctrl.name, queryctrl.default_value, queryctrl.minimum, queryctrl.maximum);
                } else if(queryctrl.type == V4L2_CTRL_TYPE_BOOLEAN) {
                    fprintf(configfile, "gen.add(\"%s\", bool_t, 0, \"%s\", %s)\n",
                            (*it)->varName.c_str(), queryctrl.name, queryctrl.default_value ? "True" : "False");
                } else if(queryctrl.type == V4L2_CTRL_TYPE_MENU) {
                    fprintf(configfile, "enum_%s = gen.enum([", (*it)->varName.c_str());

                    for(int i = queryctrl.minimum; i <= queryctrl.maximum; i++) {
                        struct v4l2_querymenu qm;
                        qm.id = queryctrl.id;
                        qm.index = i;

                        boost::this_thread::sleep(boost::posix_time::milliseconds(10));
                        if(v4l2_ioctl(pVideoIn_->fd, VIDIOC_QUERYMENU, &qm) == 0) {
                            std::string menuEntryName = (const char *)qm.name;
                            std::transform(menuEntryName.begin(), menuEntryName.end(), menuEntryName.begin(), Luvc::removeNonAlNum);
                            boost::algorithm::trim_left_if(menuEntryName, boost::algorithm::is_any_of("_"));
                            boost::algorithm::trim_left_if(menuEntryName, boost::algorithm::is_any_of("_"));
                            boost::algorithm::trim_right_if(menuEntryName, boost::algorithm::is_any_of("_"));
                            fprintf(configfile, "gen.const(\"%s\", int_t, %i, \"%s\")",
                                    menuEntryName.c_str(), i, (const char *)qm.name);
                        } else {
                            fprintf(configfile, "gen.const(\"Unkown%i\", int_t, %i, \"Unkown\")",
                                    i,i);
                        }
                        if(i != queryctrl.maximum) fprintf(configfile, ",\n  ");
                    }
                    fprintf(configfile, "], \"%s\")\n", queryctrl.name);

                    fprintf(configfile, "gen.add(\"%s\", int_t, 0, \"%s\", %i, %i, %i, edit_method=enum_%s)\n",
                            (*it)->varName.c_str(), queryctrl.name, queryctrl.default_value, queryctrl.minimum, queryctrl.maximum, (*it)->varName.c_str());
                } else if(queryctrl.type == V4L2_CTRL_TYPE_BUTTON) {
                } else if(queryctrl.type == V4L2_CTRL_TYPE_INTEGER64) {
                } else if(queryctrl.type == V4L2_CTRL_TYPE_CTRL_CLASS) {
                } else if(queryctrl.type == V4L2_CTRL_TYPE_STRING) {
                } else if(queryctrl.type == V4L2_CTRL_TYPE_BITMASK) {
                } else {
                }
            }
        }
        boost::this_thread::sleep(boost::posix_time::milliseconds(10));
    }
    fprintf(configfile, "\nexit(gen.generate(PACKAGE, \"luvc\", \"CameraParameters\"))\n");
    fflush(configfile);
    fclose(configfile);
    boost::this_thread::sleep(boost::posix_time::milliseconds(100));
}
