/*
    <one line to give the library's name and an idea of what it does.>
    Copyright (C) 2012  Markus Bader

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA

*/


#include <v4l_cam/v4l_cam.h>
#include <boost/algorithm/string.hpp>
#include <boost/program_options.hpp>

extern "C" {
#include <libv4l2.h>
#include "luvcview/v4l2uvc.h"
#include <linux/videodev2.h>
}

void updateDynamicReconfigureFile(const std::string &filename, const std::vector<V4LCam::ControlEntryPtr > &controlEntries, V4LCam::FD fd)
{
    v4l2_queryctrl queryctrl;
    v4l2_control   control_s;
    memset(&queryctrl, 0, sizeof(queryctrl));
    memset(&control_s, 0, sizeof(control_s));
    FILE *configfile;
    configfile = fopen(filename.c_str(), "w");
    fprintf(configfile, "#! /usr/bin/env python\n");
    fprintf(configfile, "#Autogenerated V4L Dynamic Control\n\n");
    fprintf(configfile, "PACKAGE='v4l_cam'\n");
    fprintf(configfile, "import roslib; roslib.load_manifest(PACKAGE)\n\n");
    fprintf(configfile, "from dynamic_reconfigure.parameter_generator import *\n");
    fprintf(configfile, "gen = ParameterGenerator()\n\n");


    fprintf(configfile, "gen.add(\"show_camera_image\", bool_t, 0, \"Show camera image\", True)\n");
	fprintf(configfile, "enum_load_save_camera_parameters = gen.enum([gen.const(\"NA\", int_t, 0, \"Do nothing\"),");
	fprintf(configfile, "  gen.const(\"load\", int_t, 1, \"Load file\"),");
	fprintf(configfile, "  gen.const(\"save\", int_t, 2, \"Save file\")], \"Load / Save camera parameters\")\n");
	fprintf(configfile, "gen.add(\"camera_control_action\", int_t, 0, \"Load / Save camera parameters\", 0, 0, 2, edit_method=enum_load_save_camera_parameters)\n");
	fprintf(configfile, "gen.add(\"camera_parameters_file\", str_t, 0, \"File to load/save parameters\", \"cfg/CameraParameters.txt\")\n");

	fprintf(configfile, "\n#Autogenerated Controls\n\n");
    for(std::vector<V4LCam::ControlEntryPtr>::const_iterator it = controlEntries.begin(); it != controlEntries.end(); it++) {
        queryctrl.id = (*it)->queryctrl->id;

        if(0 == ioctl(fd, VIDIOC_QUERYCTRL, &queryctrl)) {
            if(queryctrl.flags & V4L2_CTRL_FLAG_DISABLED) {
                continue;
            } else {
                if(queryctrl.type == V4L2_CTRL_TYPE_INTEGER) {
                    fprintf(configfile, "gen.add(\"%s\", int_t, 0, \"%s\", %i, %i, %i)\n",
                            (*it)->varName.c_str(), queryctrl.name, queryctrl.default_value, queryctrl.minimum, queryctrl.maximum);
                } else if(queryctrl.type == V4L2_CTRL_TYPE_BOOLEAN) {
                    fprintf(configfile, "gen.add(\"%s\", bool_t, 0, \"%s\", %s)\n",
                            (*it)->varName.c_str(), queryctrl.name, queryctrl.default_value ? "True" : "False");
                } else if(queryctrl.type == V4L2_CTRL_TYPE_MENU) {
                    fprintf(configfile, "enum_%s = gen.enum([", (*it)->varName.c_str());

                    for(int i = queryctrl.minimum; i <= queryctrl.maximum; i++) {
                        struct v4l2_querymenu qm;
                        qm.id = queryctrl.id;
                        qm.index = i;

                        boost::this_thread::sleep(boost::posix_time::milliseconds(10));
                        if(v4l2_ioctl(fd, VIDIOC_QUERYMENU, &qm) == 0) {
                            std::string menuEntryName = (const char *)qm.name;
                            std::transform(menuEntryName.begin(), menuEntryName.end(), menuEntryName.begin(), V4LCam::removeNonAlNum);
                            boost::algorithm::trim_left_if(menuEntryName, boost::algorithm::is_any_of("_"));
                            boost::algorithm::trim_right_if(menuEntryName, boost::algorithm::is_any_of("_"));
                            fprintf(configfile, "gen.const(\"%s\", int_t, %i, \"%s\")",
                                    menuEntryName.c_str(), i, (const char *)qm.name);
                        } else {
                            fprintf(configfile, "gen.const(\"Unkown%i\", int_t, %i, \"Unkown\")",
                                    i, i);
                        }
                        if(i != queryctrl.maximum) fprintf(configfile, ", ");
                    }
                    fprintf(configfile, "], \"%s\")\n", queryctrl.name);

                    fprintf(configfile, "gen.add(\"%s\", int_t, 0, \"%s\", %i, %i, %i, edit_method=enum_%s)\n",
                            (*it)->varName.c_str(), queryctrl.name, queryctrl.default_value, queryctrl.minimum, queryctrl.maximum, (*it)->varName.c_str());
                } else if(queryctrl.type == V4L2_CTRL_TYPE_BUTTON) {
                } else if(queryctrl.type == V4L2_CTRL_TYPE_INTEGER64) {
                } else if(queryctrl.type == V4L2_CTRL_TYPE_CTRL_CLASS) {
                } else if(queryctrl.type == V4L2_CTRL_TYPE_STRING) {
                } else if(queryctrl.type == V4L2_CTRL_TYPE_BITMASK) {
                } else {
                }
            }
        }
        boost::this_thread::sleep(boost::posix_time::milliseconds(10));
    }
    fprintf(configfile, "\nexit(gen.generate(PACKAGE, \"v4l_cam\", \"CameraParameters\"))\n");
    fflush(configfile);
    fclose(configfile);
    std::cout << "Wrote file :"<< filename << std::endl;
    boost::this_thread::sleep(boost::posix_time::milliseconds(100));
}


int main(int argc, char **argv)
{
    namespace po = boost::program_options;
    std::string filename;
    std::string device;
    po::options_description desc("Allowed Parameters");
    desc.add_options()
    ("help", "get this help message")
    ("device,d", po::value<std::string>(&device)->default_value("/dev/video0"), "Video device")
    ("file,f", po::value<std::string>(&filename), "File to genrate: like cfg/CameraParameters.cfg");

    po::variables_map vm;
    try {
        po::store(po::parse_command_line(argc, argv, desc), vm);
    } catch(const std::exception &ex) {
        std::cout << desc << std::endl;;
        exit(1);
    }
    po::notify(vm);

    if(vm.count("help") || (vm.count("file") == 0))  {
        std::cout << desc << std::endl;
        exit(1);
    }

    std::cout << "File: " << filename << std::endl;
    V4LCam v4lCam;
    V4LCam::FD fd = v4lCam.initCamera(device);
    const std::vector<V4LCam::ControlEntryPtr > &controlEntries = v4lCam.detectControlEnties();
    for(unsigned int  i = 0; i  < controlEntries.size(); i++) {
        std::cout << controlEntries[i]->getQueryCtrlInfo() << std::endl;
    }
    boost::this_thread::sleep(boost::posix_time::milliseconds(100));
    updateDynamicReconfigureFile(filename, controlEntries, fd);
    boost::this_thread::sleep(boost::posix_time::milliseconds(1000));
}
